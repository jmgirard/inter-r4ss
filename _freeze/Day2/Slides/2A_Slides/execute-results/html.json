{
  "hash": "648f9adba5e6cd26e00e5636c24c971b",
  "result": {
    "markdown": "---\nformat: \n  revealjs:\n    css: ../../styles.css\n    slide-number: true\n    show-slide-number: all\n    progress: true\n    history: true\n    hash-type: number\n    theme: default\n    code-block-background: true\n    highlight-style: github\n    code-link: false\n    code-copy: true\n    controls: true\n    pagetitle: \"Inter R4SS Day 2A\"\n    author-meta: \"Jeffrey Girard\"\n    date-meta: \"2023-06-06\"\n---\n\n\n::: {.my-title}\n# [Intermediate R]{.blue2} <br />for Social Scientists\n\n::: {.my-grey}\n[Workshop Day 2A | 2023-06-06]{}<br />\n[Jeffrey M. Girard | Pitt Methods]{}\n:::\n\n![](../../img/proud2_2780E3.svg){.absolute bottom=0 right=0 width=400}\n:::\n\n# Summarize\n\n## Summarize {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   Although we store data about many observations...\n-   ...we often want to [summarize across]{.b .blue} observations\n    -   This is like [folding]{.b .green} the tibble down to [one row]{.b .green}\n\n::: {.fragment .mt1}\n-   We've seen functions that summarize vectors\n    -   `length()`, `sum()`, `min()`, `max()`\n    -   `mean()`, `median()`, `sd()`, `var()`\n:::\n\n::: {.fragment .mt1}\n-   `summarize()` lets us use them on tibbles\n    -   It works very similarly to `mutate()`\n    -   It always creates a tibble as output\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li uhmqrsgl trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Summarize Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\nsales <- \n  tibble(\n    customer = c(1, 2, 3, 1, 3),\n    store = c(\"A\", \"A\", \"A\", \"B\", \"B\"),\n    items = c(25, 20, 16, 10, 5),\n    spent = c(685, 590, 392, 185, 123)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Summarize the typical sales\n\nmy_summary <- \n  sales |> \n  summarize(\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# PITFALL: Don't use summary() instead of summarize()\n\nmy_summary <- \n  sales |> \n  summary(\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print() # not a tibble\n\n# ==============================================================================\n\n# USECASE: Use more than one summary function\n\nmy_summary <- \n  sales |> \n  summarize(\n    total_items = sum(items),\n    total_spent = sum(spent),\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Use counting functions\n\nmy_counts <- \n  sales |> \n  summarize(\n    n_sales = n(),\n    n_customers = n_distinct(customer),\n    n_stores = n_distinct(store)\n  ) |> \n  print()\n```\n:::\n\n\n# Grouped Summarize\n\n## Grouped Summarize {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   We can also summarize a tibble [by group]{.b .blue}\n    -   This is like [folding]{.b .green} the tibble multiple times\n    -   Specifically, we fold down to [one row per group]{.b .green}\n\n::: {.fragment .mt1}\n-   We just add `.by` to `summarize()`\n    -   We can group by one or many variables\n    -   With many, we group by their combinations\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li pmwtbpap trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Grouped Summarize Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\nsales <- \n  tibble(\n    customer = c(1, 2, 3, 1, 3),\n    store = c(\"A\", \"A\", \"A\", \"B\", \"B\"),\n    items = c(25, 20, 16, 10, 5),\n    spent = c(685, 590, 392, 185, 123)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Summarize per store\n\nsales |> \n  summarize(\n    customers = n_distinct(customer),\n    items_sold = sum(items),\n    total_sales = sum(spent),\n    avg_items = mean(items),\n    avg_spent = mean(spent),\n    .by = store\n  )\n\n# ==============================================================================\n\n# USECASE: Summarize per customer\n\nsales |> \n  summarize(\n    n_visits = n(),\n    items_bought = sum(items),\n    total_spent = sum(spent),\n    stores_visited = n_distinct(store),\n    .by = customer\n  )\n\n# ==============================================================================\n\n# USECASE: Summarize per customer-store combination\n\nsales |> \n  summarize(\n    n_visits = n(),\n    items_bought = sum(items),\n    total_spent = sum(spent),\n    .by = c(customer, store)\n  )\n\n# ==============================================================================\n\n# SETUP: Let's get a larger, more realistic dataset\n\n# Extra pane > Packages tab > Install > nycflights13\n\nlibrary(\"nycflights13\")\n\nflights\n\n# ==============================================================================\n\n# USECASE: Find the carrier with the lowest average delays\n\nflights |> \n  summarize(\n    m_delay = mean(dep_delay, na.rm = TRUE),\n    .by = carrier\n  ) |> \n  arrange(m_delay)\n\n# ==============================================================================\n\n# LESSON: We can also group by multiple variables\n\n# USECASE: Let's find the day of the year with the most flights\n\nflights |> \n  summarize(\n    n_flights = n(),\n    .by = c(month, day)\n  ) |> \n  arrange(desc(n_flights))\n\n# ==============================================================================\n\n# Note how this is different from summarizing by day only (365 vs. 31)\n\nflights |> \n  summarize(\n    n_flights = n(),\n    .by = day\n  ) |> \n  arrange(desc(n_flights))\n```\n:::\n\n\n# Grouped Mutate\n\n## Grouped Mutate {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   We can also [mutate]{.b .blue} a tibble by group\n    -   Adds the summary values in a new column\n    -   They will be recycled for groups with many rows\n    \n::: {.fragment .mt1}\n-   We now have four useful tools for different jobs\n    -   Ungrouped summarize: fold to one row overall\n    -   Grouped summarize: fold to one row per group\n    -   Ungrouped mutate: add summaries overall\n    -   Grouped mutate: add summaries per group\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li qygayvwp trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Grouped Mutate Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nsales\n\n# Calculates the total sum (across both stores)\nsales |> \n  summarize(\n    items_sum_total = sum(items)\n  )\n\n# Calculates the store sums\nsales |> \n  summarize(\n    items_sum_store = sum(items),\n    .by = store\n  )\n\n# Appends and recycles the total sum (across both stores)\nsales |> \n  mutate(\n    items_sum_total = sum(items),\n    items_pct_total = items / items_sum_total\n  )\n\n# Appends and recycles the store sums\nsales |> \n  mutate(\n    items_sum_store = sum(items),\n    items_pct_store = items / items_sum_store,\n    .by = store\n  )\n\n# What if you want both? You can!\n\nsales |> \n  mutate(\n    items_sum_total = sum(items),\n    items_pct_total = items / items_sum_total\n  ) |> \n  mutate(\n    items_sum_store = sum(items),\n    items_pct_store = items / items_sum_store,\n    .by = store\n  )\n\nflights \n\n# .by can also be used with mutate()\nflights |> \n  select(year:dep_time, carrier, dep_delay) |> \n  mutate(\n    mean_dep_delay = mean(dep_delay, na.rm = TRUE),\n    .by = carrier\n  )\n\n# Compare this to summarize version\nflights |> \n  select(year:dep_time, carrier, dep_delay) |> \n  summarize(\n    mean_dep_delay = mean(dep_delay, na.rm = TRUE),\n    .by = carrier\n  )\n\n# Example longitudinal data\ndat <- \n  tibble(\n    person = rep(101:103, each = 4),\n    sex = rep(c(\"M\", \"F\", \"M\"), each = 4),\n    age = rep(c(13, 10, 12), each = 4), \n    visit = rep(1:4, times = 3),\n    score = round(rnorm(12), digits = 1)\n  ) |> \n  print()\n\n# Another grouped mutate vs grouped summarize example\ndat |> \n  mutate(\n    n_visits = n(), \n    .by = person\n  )\n\ndat |> \n  summarize(\n    n_visits = n(),\n    .by = person\n  )\n\n# Add row numbers with row_number()\ndat2 <- \n  dat |> \n  select(-visit) |> \n  print()\n\ndat2 |> \n  mutate(\n    visit_total = row_number()\n  )\n\ndat2 |> \n  mutate(\n    visit_person = row_number(),\n    .by = person\n  )\n```\n:::\n\n\n# Tidy Control Flow\n\n## Tidy Control Flow {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n- Part of what makes computers so useful is their ability to [change their behavior conditionally]{.b .green}\n    - **If** [condition] is true... **then** do [behavior]\n    \n::: {.fragment .mt1}\n- Programming this is called [control flow]{.b .blue}\n    - Basic control flow is built into R (no packages)\n    - [Tidy]{.b .green} control flow is easier **while wrangling**\n:::\n\n::: {.fragment .mt1}\n- There are two main tidy control flow functions\n    - For two outcomes: `if_else()`\n    - For many outcomes: `case_when()`\n:::\n\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li usjxhgom trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Tidy Control Flow Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nlibrary(tidyverse)\n\n# if_else to assign to one of two values conditionally\n\n## simple example\nx <- 6\nif_else(\n  condition = x > 10,\n  true = \"large\",\n  false = \"small\"\n)\n\n## Compressed\nif_else(x > 10, \"large\", \"small\")\n\n## Vectorized\nx <- c(6, 16, 3)\nif_else(x > 10, \"large\", \"small\")\n\n## Nested\nif_else(\n  condition = x > 10,\n  true = \"large\",\n  false = if_else(x > 5, \"medium\", \"small\")\n)\n\n# case_when to assign to one of 3+ values conditionally\n\n## simple example\nx <- c(6, 16, 3)\ncase_when(\n  x > 10 ~ \"large\",\n  x > 5 ~ \"medium\",\n  x <= 5 ~ \"small\"\n)\n\n## We can also use `.default =` for when no conditions are met\ncase_when(\n  x > 10 ~ \"large\",\n  x > 5 ~ \"medium\",\n  .default = \"small\"\n)\n\n## Pitfall: ordering the conditions poorly\ncase_when(\n  x > 5 ~ \"medium\", \n  x > 10 ~ \"large\",\n  .default = \"small\"\n)\n\n# Working within mutate: simple examples \n\n## Example data\nsitetemps <- \n  tibble(\n    site = c(2, 1, 2, 3, 3, 3, 1, 1, 2),\n    temp = c(-2.1, 38.6, 4.6, -0.2, 4.5, 0.6, 37.6, 36.7, 102.3)\n  ) |> \n  print()\n\n## if_else within mutate\nsitetemps |> \n  mutate(\n    metric = if_else(\n      condition = site == 1,\n      true = \"F\",\n      false = \"C\"\n    )\n  )\n\n## case_when within mutate\nsitetemps |> \n  mutate(\n    nation = case_when(\n      site == 1 ~ \"US\",\n      site == 2 ~ \"DE\",\n      site == 3 ~ \"FR\",\n      .default = NA\n    )\n  )\n\n# Working within mutate: complex examples\n\n## Conditionally transforming values\nsitetemps |> \n  mutate(\n    metric = if_else(site == 1, \"F\", \"C\"),\n    tempC = if_else(\n      condition = metric == \"F\",\n      true = (temp - 30) * (5 / 9), \n      false = temp\n    ),\n    state = case_when(\n      tempC < 0 ~ \"solid\",\n      tempC < 100 ~ \"liquid\",\n      tempC > 100 ~ \"gas\"\n    )\n  )\n```\n:::\n\n\n# Tidy Selection\n\n## Tidy Selection {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   `filter()` lets us retain rows using criteria\n    -   A version for columns would be convenient!\n\n::: {.fragment .mt1}\n-   This is essentially what tidy selection does\n    -   We can `select()` columns using criteria\n    -   It's like an extension of the `:` sugar\n:::\n\n::: {.fragment .mt1}\n-   We will use selection helpers and predicates\n    -   `starts_with()`, `contains()`, etc.\n    -   `everything()`, `last_col()`\n    -   `where()` and `is.*()`\n\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li tvyxmjyo trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Tidy Selection Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nlibrary(palmerpenguins)\n\npenguins\n\n# Starts with\n\npenguins |> \n  select(starts_with(\"bill_\"))\n\n# PITFALL\n\npenguins |> \n  starts_with(\"bill_\") # error - don't forget select()\n  \n\n# Ends with\n\npenguins |> \n  select(ends_with(\"_mm\"))\n\n# Contains\n\npenguins |> \n  select(contains(\"_length_\"))\n\n# Where\n\npenguins |> \n  select(where(is.factor))\n\npenguins |> \n  select(where(is.numeric))\n\npenguins |> \n  select(where(is.character))\n\n# PITFALL\n\npenguins |> \n  select(where(is.factor())) # error - don't include () after is.*\n\n# Everything\n\npenguins |> \n  select(everything())\n\n# Last Column\n\npenguins |> \n  select(last_col())\n\npenguins |> \n  select(body_mass_g:last_col())\n\n# Negating Criteria\n\npenguins |> \n  select(!ends_with(\"_mm\"))\n\n# Combining Criteria\n\npenguins |> \n  select(where(is.factor) | starts_with(\"body_\"))\n\npenguins |> \n  select(species, where(is.numeric))\n\npenguins |> \n  select(ends_with(\"_mm\") & !contains(\"_depth_\"))\n```\n:::\n\n\n# Iterating Across\n\n## Iterating Across {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   We can apply functions to many columns at once\n    -   This is done using the `across()` function\n    -   It goes inside `mutate()` and `summarize()`\n\n::: {.fragment .mt1}\n-   `across()` pairs very well with tidy selection\n    -   e.g., do this to variables starting with \"x\"\n    -   e.g., do this to all numeric variables\n:::\n\n::: {.fragment .mt1}\n-   Advanced: \"Anonymous functions\"\n    -   Call current col x, then round x to 2 digits\n    -   e.g., `\\(x) round(x, digits = 2)`\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li krmfspeu trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Across Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nstarwars\n\n# Applying the same mutation to multiple variables is a pain\nstarwars |> \n  mutate(\n    hair_color = factor(hair_color),\n    skin_color = factor(skin_color),\n    eye_color = factor(eye_color),\n  )\n\n# dplyr 1.0.0 added across() to make this easier\n\nstarwars |> \n  mutate(\n    across(\n      .cols = c(hair_color, skin_color, eye_color), \n      .fns = factor\n    )\n  )\n\n# We can also use tidyverse shortcuts like the colon (:)\nstarwars |> \n  mutate(\n    across(\n      .cols = c(hair_color:eye_color), \n      .fns = factor\n    )\n  )\n\n# We can also compress it to take up less space\nstarwars |> \n  mutate(across(c(hair_color:eye_color), factor))\n\n# We can also use a tidy selection helper when appropriate\nstarwars |> \n  mutate(\n    across(\n      .cols = ends_with(\"color\"), \n      .fns = factor\n    )\n  )\n\nstarwars |>  \n  mutate(across(.cols = where(is.character), .fns = factor))\n\n# For more control, we use an anonymous function\n\nstarwars |> \n  mutate(\n    height = height * 1000,\n    mass = mass * 1000\n  )\n\nstarwars |> \n  mutate(\n    across(\n      .cols = c(height, mass), \n      .fns = \\(x) x * 1000\n    )\n  )\n\n# Across with summarize\n\nstarwars |> \n  summarize(\n    height = mean(height, na.rm = TRUE),\n    mass = mean(mass, na.rm = TRUE),\n    birth_year = mean(birth_year, na.rm = TRUE)\n  )\n\nstarwars |> \n  summarize(\n    across(\n      .cols = c(height, mass, birth_year), \n      .fns = \\(x) mean(x, na.rm = TRUE)\n    )\n  )\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}