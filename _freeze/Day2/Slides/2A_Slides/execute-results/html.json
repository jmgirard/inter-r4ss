{
  "hash": "6e81c9250ca58b3f587dc7a30e694255",
  "result": {
    "markdown": "---\nformat: \n  revealjs:\n    css: ../../styles.css\n    slide-number: true\n    show-slide-number: all\n    progress: true\n    history: true\n    hash-type: number\n    theme: default\n    code-block-background: true\n    highlight-style: github\n    code-link: false\n    code-copy: true\n    controls: true\n    pagetitle: \"Inter R4SS Day 2A\"\n    author-meta: \"Jeffrey Girard\"\n    date-meta: \"2023-06-06\"\n---\n\n\n::: {.my-title}\n# [Intermediate R]{.blue2} <br />for Social Scientists\n\n::: {.my-grey}\n[Workshop Day 2A | 2023-06-06]{}<br />\n[Jeffrey M. Girard | Pitt Methods]{}\n:::\n\n![](../../img/proud2_2780E3.svg){.absolute bottom=0 right=0 width=400}\n:::\n\n# Summarize\n\n## Summarize {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   Although we store data about many observations...\n-   ...we often want to [summarize across]{.b .blue} observations\n    -   This is like [folding]{.b .green} the tibble down to [one row]{.b .green}\n\n::: {.fragment .mt1}\n-   We've seen functions that summarize vectors\n    -   `length()`, `sum()`, `min()`, `max()`\n    -   `mean()`, `median()`, `sd()`, `var()`\n:::\n\n::: {.fragment .mt1}\n-   `summarize()` lets us use them on tibbles\n    -   It works very similarly to `mutate()`\n    -   It always creates a tibble as output\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li uhmqrsgl trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Summarize Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\nsales <- \n  tibble(\n    customer = c(1, 2, 3, 1, 3),\n    store = c(\"A\", \"A\", \"A\", \"B\", \"B\"),\n    items = c(25, 20, 16, 10, 5),\n    spent = c(685, 590, 392, 185, 123)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Summarize the typical sales\n\nmy_summary <- \n  sales |> \n  summarize(\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# PITFALL: Don't use summary() instead of summarize()\n\nmy_summary <- \n  sales |> \n  summary(\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print() # not a tibble\n\n# ==============================================================================\n\n# USECASE: Use more than one summary function\n\nmy_summary <- \n  sales |> \n  summarize(\n    total_items = sum(items),\n    total_spent = sum(spent),\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Use counting functions\n\nmy_counts <- \n  sales |> \n  summarize(\n    n_sales = n(),\n    n_customers = n_distinct(customer),\n    n_stores = n_distinct(store)\n  ) |> \n  print()\n```\n:::\n\n\n# Grouped Summarize\n\n## Grouped Summarize {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   We can also summarize a tibble [by group]{.b .blue}\n    -   This is like [folding]{.b .green} the tibble multiple times\n    -   Specifically, we fold down to [one row per group]{.b .green}\n\n::: {.fragment .mt1}\n-   We just add the `.by` argument to `summarize()`\n    -   We can group by one or many variables\n    -   With many, we group by their combinations\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li pmwtbpap trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Grouped Summarize Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\nsales <- \n  tibble(\n    customer = c(1, 2, 3, 1, 3),\n    store = c(\"A\", \"A\", \"A\", \"B\", \"B\"),\n    items = c(25, 20, 16, 10, 5),\n    spent = c(685, 590, 392, 185, 123)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Summarize per store\n\nsales |> \n  summarize(\n    customers = n_distinct(customer),\n    items_sold = sum(items),\n    total_sales = sum(spent),\n    avg_items = mean(items),\n    avg_spent = mean(spent),\n    .by = store\n  )\n\n# ==============================================================================\n\n# USECASE: Summarize per customer\n\nsales |> \n  summarize(\n    n_visits = n(),\n    items_bought = sum(items),\n    total_spent = sum(spent),\n    stores_visited = n_distinct(store),\n    .by = customer\n  )\n\n# ==============================================================================\n\n# USECASE: Summarize per customer-store combination\n\nsales |> \n  summarize(\n    n_visits = n(),\n    items_bought = sum(items),\n    total_spent = sum(spent),\n    .by = c(customer, store)\n  )\n\n# ==============================================================================\n\n# SETUP: Let's get a larger, more realistic dataset\n\n# Extra pane > Packages tab > Install > nycflights13\n\nlibrary(\"nycflights13\")\n\nflights\n\n# ==============================================================================\n\n# USECASE: Find the carrier with the lowest average delays\n\nflights |> \n  summarize(\n    m_delay = mean(dep_delay, na.rm = TRUE),\n    .by = carrier\n  ) |> \n  arrange(m_delay)\n\n# ==============================================================================\n\n# LESSON: We can also group by multiple variables\n\n# USECASE: Let's find the day of the year with the most flights\n\nflights |> \n  summarize(\n    n_flights = n(),\n    .by = c(month, day)\n  ) |> \n  arrange(desc(n_flights))\n\n# ==============================================================================\n\n# Note how this is different from summarizing by day only (365 vs. 31)\n\nflights |> \n  summarize(\n    n_flights = n(),\n    .by = day\n  ) |> \n  arrange(desc(n_flights))\n```\n:::\n\n\n# Grouped Mutate\n\n## Grouped Mutate {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   We can also [mutate]{.b .blue} a tibble by group\n    -   Adds the summary values in a new column\n    -   They will be recycled for groups with many rows\n    \n::: {.fragment .mt1}\n-   We now have four useful tools for different jobs\n    -   Ungrouped summarize: fold to one row overall\n    -   Grouped summarize: fold to one row per group\n    -   Ungrouped mutate: add summaries overall\n    -   Grouped mutate: add summaries per group\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li qygayvwp trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Grouped Mutate Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nsales\n\n# Calculates the total sum (across both stores)\nsales |> \n  summarize(\n    items_sum_total = sum(items)\n  )\n\n# Calculates the store sums\nsales |> \n  summarize(\n    items_sum_store = sum(items),\n    .by = store\n  )\n\n# Appends and recycles the total sum (across both stores)\nsales |> \n  mutate(\n    items_sum_total = sum(items),\n    items_pct_total = items / items_sum_total\n  )\n\n# Appends and recycles the store sums\nsales |> \n  mutate(\n    items_sum_store = sum(items),\n    items_pct_store = items / items_sum_store,\n    .by = store\n  )\n\n# What if you want both? You can!\n\nsales |> \n  mutate(\n    items_sum_total = sum(items),\n    items_pct_total = items / items_sum_total\n  ) |> \n  mutate(\n    items_sum_store = sum(items),\n    items_pct_store = items / items_sum_store,\n    .by = store\n  )\n\nflights \n\n# .by can also be used with mutate()\nflights |> \n  select(year:dep_time, carrier, dep_delay) |> \n  mutate(\n    mean_dep_delay = mean(dep_delay, na.rm = TRUE),\n    .by = carrier\n  )\n\n# Compare this to summarize version\nflights |> \n  select(year:dep_time, carrier, dep_delay) |> \n  summarize(\n    mean_dep_delay = mean(dep_delay, na.rm = TRUE),\n    .by = carrier\n  )\n\n# Example longitudinal data\ndat <- \n  tibble(\n    person = rep(101:103, each = 4),\n    sex = rep(c(\"M\", \"F\", \"M\"), each = 4),\n    age = rep(c(13, 10, 12), each = 4), \n    visit = rep(1:4, times = 3),\n    score = round(rnorm(12), digits = 1)\n  ) |> \n  print()\n\n# Another grouped mutate vs grouped summarize example\ndat |> \n  mutate(\n    n_visits = n(), \n    .by = person\n  )\n\ndat |> \n  summarize(\n    n_visits = n(),\n    .by = person\n  )\n\n# Add row numbers with row_number()\ndat2 <- \n  dat |> \n  select(-visit) |> \n  print()\n\ndat2 |> \n  mutate(\n    visit_total = row_number()\n  )\n\ndat2 |> \n  mutate(\n    visit_person = row_number(),\n    .by = person\n  )\n```\n:::\n\n\n# Tidy Selection\n\n## Tidy Selection {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   `filter()` lets us retain rows using criteria\n    -   A version for columns would be convenient!\n\n::: {.fragment .mt1}\n-   This is essentially what tidy selection does\n    -   We can `select()` columns using criteria\n    -   It's like an extension of the `:` sugar\n:::\n\n::: {.fragment .mt1}\n-   We will use selection helpers and predicates\n    -   `starts_with()`, `contains()`, etc.\n    -   `everything()`, `last_col()`\n    -   `where()` and `is.*()`\n\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li tvyxmjyo trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Tidy Selection Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nlibrary(palmerpenguins)\n\npenguins\n\n# Starts with\n\npenguins |> \n  select(starts_with(\"bill_\"))\n\n# PITFALL\n\npenguins |> \n  starts_with(\"bill_\") # error - don't forget select()\n  \n\n# Ends with\n\npenguins |> \n  select(ends_with(\"_mm\"))\n\n# Contains\n\npenguins |> \n  select(contains(\"_length_\"))\n\n# Where\n\npenguins |> \n  select(where(is.factor))\n\npenguins |> \n  select(where(is.numeric))\n\npenguins |> \n  select(where(is.character))\n\n# PITFALL\n\npenguins |> \n  select(where(is.factor())) # error - don't include () after is.*\n\n# Everything\n\npenguins |> \n  select(everything())\n\n# Last Column\n\npenguins |> \n  select(last_col())\n\npenguins |> \n  select(body_mass_g:last_col())\n\n# Negating Criteria\n\npenguins |> \n  select(!ends_with(\"_mm\"))\n\n# Combining Criteria\n\npenguins |> \n  select(where(is.factor) | starts_with(\"body_\"))\n\npenguins |> \n  select(species, where(is.numeric))\n\npenguins |> \n  select(ends_with(\"_mm\") & !contains(\"_depth_\"))\n```\n:::\n\n\n# Across\n\n## Across {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   We can apply functions to many columns at once\n    -   This is done using the `across()` function\n    -   It goes inside `mutate()` and `summarize()`\n\n::: {.fragment .mt1}\n-   `across()` pairs very well with tidy selection\n    -   e.g., do this to variables starting with \"x\"\n    -   e.g., do this to all numeric variables\n:::\n\n::: {.fragment .mt1}\n-   Advanced: \"Anonymous functions\"\n    -   Call current col x, then round x to 2 digits\n    -   e.g., `\\(x) round(x, digits = 2)`\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li krmfspeu trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Across Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nstarwars\n\n# Applying the same mutation to multiple variables is a pain\nstarwars |> \n  mutate(\n    hair_color = factor(hair_color),\n    skin_color = factor(skin_color),\n    eye_color = factor(eye_color),\n  )\n\n# dplyr 1.0.0 added across() to make this easier\n\nstarwars |> \n  mutate(\n    across(\n      .cols = c(hair_color, skin_color, eye_color), \n      .fns = factor\n    )\n  )\n\n# We can also use tidyverse shortcuts like the colon (:)\nstarwars |> \n  mutate(\n    across(\n      .cols = c(hair_color:eye_color), \n      .fns = factor\n    )\n  )\n\n# We can also compress it to take up less space\nstarwars |> \n  mutate(across(c(hair_color:eye_color), factor))\n\n# We can also use a tidy selection helper when appropriate\nstarwars |> \n  mutate(\n    across(\n      .cols = ends_with(\"color\"), \n      .fns = factor\n    )\n  )\n\nstarwars |>  \n  mutate(across(.cols = where(is.character), .fns = factor))\n\n# For more control, we use an anonymous function\n\nstarwars |> \n  mutate(\n    height = height * 1000,\n    mass = mass * 1000\n  )\n\nstarwars |> \n  mutate(\n    across(\n      .cols = c(height, mass), \n      .fns = \\(x) x * 1000\n    )\n  )\n\n# Across with summarize\n\nstarwars |> \n  summarize(\n    height = mean(height, na.rm = TRUE),\n    mass = mean(mass, na.rm = TRUE),\n    birth_year = mean(birth_year, na.rm = TRUE)\n  )\n\nstarwars |> \n  summarize(\n    across(\n      .cols = c(height, mass, birth_year), \n      .fns = \\(x) mean(x, na.rm = TRUE)\n    )\n  )\n```\n:::\n\n\n# Scale Scores\n\n## Scale Scores {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   In social science, we often use [scale scores]{.b .blue}\n    -   Multiple similar items are combined\n    -   Sums and means are both common\n\n::: {.fragment .mt1}\n-   Calculating scale scores from items is tricky\n    -   When each item is a column...\n    -   ...we calculate scale scores **per row**\n:::\n\n::: {.fragment .mt1}\n-   We can either group per row (using `.by`)\n    -   Or use special row-based functions\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li bdfzpkxv trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Scale Scores Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Simulate a longitudinal dataset with a five-item scale\ndf <- \n  tibble(\n    subject = rep(101:103, each = 3),\n    visit = rep(1:3, times = 3),\n    q1 = sample(x = 0:4, size = 9, replace = TRUE),\n    q2 = sample(x = 0:4, size = 9, replace = TRUE),\n    q3 = sample(x = 0:4, size = 9, replace = TRUE),\n    q4 = sample(x = 0:4, size = 9, replace = TRUE),\n    q5 = sample(x = 0:4, size = 9, replace = TRUE),\n  ) |> \n  print()\n\n# USECASE: Calculate subjects' scores per visit\n\n# Solution 1 (calculate sums and means \"by-hand\")\ndf |> \n  mutate(\n    total_q = q1 + q2 + q3 + q4 + q5,\n    mean_q = (q1 + q2 + q3 + q4 + q5) / 5\n  )\n\n# PITFALL: Attempt to use functions for convenience\ndf |> \n  mutate(\n    total_q = sum(c(q1, q2, q3, q4, q5)),\n    mean_q = mean(c(q1, q2, q3, q4, q5))\n  )\n# But the answers aren't what we wanted! These are ungrouped mutates!\n\n# Solution 2 (turn them into grouped mutates)\ndf |> \n  mutate(\n    total_q = sum(c(q1, q2, q3, q4, q5)),\n    mean_q = mean(c(q1, q2, q3, q4, q5)),\n    .by = c(subject, visit)\n  )\n# These are the answers we wanted\n\n# USECASE: Can we use tidy selection here?\n\n# The : operator does work if they are in order!\ndf |> \n  mutate(\n    total_q = sum(q1:q5),\n    mean_q = mean(q1:q5),\n    .by = c(subject, visit)\n  )\n\n# But starts_with() doesn't...\ndf |> \n  mutate(\n    total_q = sum(starts_with(\"q\")),\n    mean_q = mean(starts_with(\"q\")),\n    .by = c(subject, visit)\n  )\n# Error...\n\n# Solution 3 (use row functions and pick, no .by necessary)\ndf |> \n  mutate(\n    total_q = rowSums(pick(starts_with(\"q\"))),\n    mean_q = rowMeans(pick(starts_with(\"q\")))\n  )\n\n# PITFALL (don't include your sum in your mean)\ndf |> \n  mutate(\n    q_total = rowSums(pick(starts_with(\"q\"))),\n    q_mean = rowMeans(pick(starts_with(\"q\")))\n  )\n# Note that the means are now much higher because they include q_total\n# This is because q_total also starts with q and comes first in mutate()\n```\n:::",
    "supporting": [
      "2A_Slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}